DP(동적계획법)        경우의수를 구하라는 문제는 거의 DP 또한 뭔가 1부터 계속 n까지의 뭔가모를 점화식을 세울 수 있을 것같다면 1차원이든 2차원이든(for문2번쓰면됨) 으로 식세워서 풀어나가자. 초기 값 설정이 매우 중요하고 마지막 n일 때 자료형이 초과되지 않는지 살펴볼것!!!,"Top-down방법                                   1.문제를 작은 문제로 나눈다. 2 작은문제를 푼다. 3. 작은문제를 풀었으니 이제, 문제를 푼다.->재귀를 활용하는 방법","Bottom-up방법                                                 1.문제를 크기가 작은 문제부터 차례대로 푼다. 2.문제의 크기를 조금씩 크게 만들면서 점점 푼다(보통 포문을 시작부터 쭉 풀어나간다. 점화식과 시그마개념) 3. 작은문제를 풀면서 쭉 왔기 때문에, 큰문제는 항상 풀 수 있다. 그러다보면 언젠간 풀어야 하는 문제를 풀수 있다. 그리고 점화식이 1차원인 경우와 2차원인 경우가 있다!!!매우 중요!!!",
1463,1로만들기,1로만들 때 중요한 부분은 -1한 값은 일단 최소값을 가진 값이어야 된다는 점이다. 즉 작은 문제로 쪼갰ㅇ르 때 작은 문제는 이미 최소인 상태이므로 그 합이 큰문제의 답이 된다는 것이다. 그리고 *****1인경우 0인경우 2인경우도 잘 고려해서 for문을 돌려야 한다. ******그리고 조금 더 효율적으로 짜기 위해서는 일단 가장 우선순위가 낮은거 할당하고 그 뒤에 비교해서 값을 업데이트 하는 방법이 좋다. 예를들면 빼기1한거 값넣고 그 후에 2로 나눈거랑 비교하고 그후에 3으로 나눈거랑 비교하여 최종 값을 업데이트 하는 방식이다.,
11726,2Xn 타일링,,
11727,2Xn 타일링2,,
9095,"1,2,3 더하기",결국 1을 뺀 것들과 2를 뺀 것들 3을 뺀 것들의 합으로 이루어짐을 파악할 것 1을 뺀 것들의 결과는 2를 뺸 것들의 결과와 같지 않다. 또한 2는 2그자체도 있으므로 3가지임을 파악해야함!!,
10844,쉬운 계단 수,"이차원 동적계획법에 대한 문제이다. 이차원이라는 것은 마지막만 생각하는데 그 마지막의 경우의 수가 그 마지막 전에 즉 뒤에서 두번째 경우에 따라 마지막이 다른 경우를 말한다. 이 문제에서는 마지막에 1인경우 2인경우..9인경우 9가지들의 합으로 이루어져있다. 길이n 마지막 수k 두가지의 요소를 섞은 차원의 작은 문제들의 합을 구하고 최종적으로 전부 더해줘야 답이 나오는 형식이다. 매우 중요!!!그리고 초기화 잘 해주고, 크기 자료형을 잘 살펴보고 10000000으로 나누는것도 계속 해주는 것을 잊지 말것!!! ",
2193,이친 수,"어떤 경우의 수를 구하라는 문제는 보통 DP로 풀 수 있다. 그리고 작은 문제로 쪼개볼 생각을 시작해야 되는데 가장 쉬운 접근 방법은 맨 마지막 경우를 생각해보고 그 전 작은 결과의 합으로 표현하는 것이다. 이친수 문제도 맨 마지막에 올 수 있는 경우는 0인경우와 1인경우로만 나뉘고 1일때는 그 앞은 무조건 0이 와야 되고 그 앞은 아무거나 와도 괜찮다. 그러므로 n-1과 n-2의 합으로 표현할 수 있게 된다. **********매우 중요한 것은 검사할 때 1부터 90이므로 90이 자료형에 걸리는지 확인해햐 한다. 너무 큰 수기 떄문에 int배열이 아니라 long long 배열에 저장해야 하며, 출력형식은 printf(%lld,d[n]);으로 해주어야 한다.",
1699,제곱수의 합,,
2225,합분해,,
BFS(넓이 우선탐색),"dfs와 bfs의 차이는 bfs는 깊이가 정해져 있지 않아서 일단 계속 돌아다니면서 최소값을 찾는 문제이며, dfs는 특정 깊이까지 무조건 탐색을 해야하며, 그 특정깊이에 다다랐을 때의 최소값을 찾는 문제라 보면 된다. 여기서 최소값은 최대값이어도 되고 엇쨋든 최대 최소를 구하는데, 이동할 때 항상 같은 가중치로 이동하는 경우는 dfs,bfs문제로 풀린다. 다른 가중치라면 어려워지므로….그떄가서 생각하기!",,
1697,숨바꼭질,"제일중요한건 모든 테스트 케이스를 다 맞는 것인데, 문제 개수가 중요한 것이 아니다!!!!->숨겨진 테스트케이스를 생각하는 법은 입력값이 결과와 같아서 결과가 0이 출력되는 경우, 1이 출력되는 경우를 생각하는것, 범위가 0부터 100이면 범위의 값이 나오게 되는 경우 이런 경우를 고려해줘야한다. 이 문제에서도 n과 k가 애초부터 같게 입력되면 0을 반환해야한다. 그리고 BFS알고리즘의 핵심은 방문한 곳은 1로 체크해 나가는 것이고 ,깊이는 그 전 상태에서 1이 깊어지는 개념이다. 큐에 넣어놓고 가능한 옆으로 돌아보고 그 뒤로 다음 깊이로 가서 탐색하는 것이다. 또한 queue<pair<int, int> > q1;//> >nested에러가 남!!! 띄어쓰기 중요!!하다는 것 !!!!!",
13913,숨바꼭질 4,"메모리 초과 문제를 주의하자..!!!!!역시나 예외 테스트케이스를 잘 파악해야한다. Nk가 같은 경우!!!제발!!!! 그리고 그간의 경로를 출력해야 하는 문제라면 그간의 경로를 계속 들고다니지 않고, 부모것 딱 하나만 들고다니다가 추후 최종상황에서 부모를 찾아서 while문을 돌리면 결과를 얻을 수 있다. 이것으로 메모리 문제를 해결할 수 있음!!!!",
삼성기출문제,,,
,시험감독,o,시험감독은 예외조건이랑 꼼꼼하게 검토하는 능력이 필요하다. 나누기와 몫의 관계를 잘 파악하고 만약 큰감독이 모두를 케어하게 되면 굳이 나눌필요가 없으므로 그 조건을 잘 고려해야한다.
,테트로미노,o,"모양19가지를 완벽하게 꼼꼼히 만드는 능력이 필요!! 만약에 DFS로 풀거라면 생각해줘야 하는것!! 한 점에서 앞으로 가는 곳은 총 4가지이고, 그 4가지에서 계속 나아가면서 깊이가 3이될 때 그 합의 최대값을 구하는 것으로 생각하면 된다. 그런데 중요한 부분은 방문한 곳은 다시가면 안된다는 점 ~ 그래서 그 부분을 부모를 들고다니면서 해결하도록 하자. 그리고 시작상황에 대해서도 조심할것 그리고 ㅗ,ㅜ,ㅓ,ㅏ,모양은 같은곳을 다시가야 되므로 dfs로 해결할 수 없으니 따로 조건을 확인해주는 작업을 추가해야 한다.****주의사항 *** 이동 경로의 조건을 잘 설정해주어야함 음수로 가거나, n,m보다 더 앞으로가면 안됨!!"
,퇴사,o,"DP문제지만, 나의 경우에는 점화식을 세울 수 없었다….최대값,최소값구하는 문제,경우의수 구하는 문제 등 ~까지의 값과 그 다음날의 값의 최대값 이런식으로 마지막을 기준으로 그전까지의 작은문제도 항상 최대가 된다면 DP로 풀수있고 식도 세울 수 있어야 한다. 연습이 좀더 필요할 것같다. 아무튼 새로운 방법으로 풀어본 것은 15일이 최대이므로 2의 15승 가지의 부분집합으로 표현할 수 있고, 이 부분집합들을 전부 점검해도 시간이 맞아서 이렇게 풀었다. 부분집합 모든 경우의수를 점검하는 방법은 비트연산자와 비트마스크를 활용하는 법인데, 이 코드 구조는 꼭 기억하고 있어야 한다. 1<<n을 포문 두번에 걸쳐서 점검하는 방식이다. 만약에 두번째 포문에서 1<<k와 i가 &연산 했을 때 참이 되면 해당번째에 부분집합이 포함됨을 의미한다. 이것을 이용해서 날짜 조건을 잘 파악하고 풀어나가면 된다."
,주사위 굴리기,o,
,연구소,,
,로봇청소기,,
,째로탈출2,o,"정말 오래 걸린 문제…!!! 이 문제의 해결방법은 다음과 같다. 일단 문제를 충분히 반복적으로 읽는다. 키포인트는 R만 구멍을 나가야 되며, 그외 경우는 전부 안된다. 그외 경우는 둘다 움직이지 못해 더 이상 나갈 곳이 없는 경우, 깊이가 10이 넘어가는 경우에 멈추게 된다. 그리고 무효가 되는 경우는 파란공만 떨어진 경우, 이미 같던 곳을 다시 방문한 경우(이 경우는 파란공의 상태와 빨간공의 상태 전부 필요)이다. 이러한 전제 조건들을 잘 고려하여, bfs로 푸는데 큐에 집어넣기 전에 이동하는 경로를 전부 조건에 맞게 구한 뒤 넣어주고, 방문체크해주고, pop해주면 되는데 pop순서가 중요하다. pop을 맨 처음에 해주어야 중간에 continue됐을 때 pop을 안까먹고 할 수 있다. 아니면 conintue하기 전에 pop을 꼭 해줘야한다. 그리고 이 경우에서 4방향으로 도는데, 엄마의 상태가 파랑 빨강 2가지 경우가 있는데 이 때 각4번의 경우마다 엄마는 동일해야 하므로 초기화를 꼭 해줘야 한다. 그리고 가장 중요한것!!!!****이동하는ㄱ것... 일단 4가지 경우로 위 아래 오른쪽 왼쪽이 있지만, 중력에 의해 두 색깔에도 순서가 정해지게 되고, 먼저 앞에 움직인 것에 의해 뒤 색깔 이동에 제약이 생기는 것 !!!핵심 포인트, 또한 구멍에 빠지고 나면, 사라지게 되므로 그것도 잘 생각해야함 구멍에 빠지면 일단 큐에 안넣는 것으로 생각하고, 4가지에 순서를 더하면 총 8가지의 경우의 수가 나온다. 그리고 빨간공이 먼저간 경우와 파란공이 먼저간 경우를 나눠서 풀어주고, 최종 이동된 위치를 큐에 집어넣어준다.!!!!! 또한 큐에 넣을 때는 이미 간곳인지 아닌지를 검사하여 아예 이동이 안된 경우는 더이상 보지 않도록 해서 해결한다. "
,뱀,,
,욕심쟁이 판다,,
,문자판,,
,안전영역,,
,탈출,,
,2048(Easy),o,
,뿌요뿌요,,
,,,
카카오 코드 페스티발,,,
,,,
카카오 블라인드 공채 1차,,,
,,,
,,,
,,,
,,,
NHN 신입 공채 기출문제 모의 코딩테스트,,,
,가장 가까운 두 점,o,알고리즘 라이브러리를 써서 벡터를 정렬할 수 있다. 기본적으로 오름차순 정렬은 손쉽게 begin과 end를 이용해서 만들 수 있다. 또한 10자리까지만 int형은 표현할 수 있으므로 long long의 자료형을 써주는 것이 중요하다. 정렬을 하고나서 거리를 비교하면 무조건 최소거리가 나오면 그다음 항과는 최소거리가 아니게 된다. 왜냐면 정렬이 되어있기 때문이다. 뒤에는 앞에보다 값이 무조건 크니까!! 이점을 이용하면 빠르게 풀 수 있다. 
,펠린드롬 넘버 만들기,,"숫자를 뒤집는 함수에 대해서 생각해보자. 재귀를 이용하면 되는데, 10으로 나눈 나머지를 더하고 곱하기 10을 하고 그뒤에 10으로 나눴을 때의 몫과 앞의 값을 가지고 다시함수를 반복한다. 그러면 해당수의 뒤집어진 값이 나오게 되는데, 이 때 와일문을 끝내는 조건을 10으로 나눈 몫이 0일 때 끝내면 된다. 이렇게 뒤집어진 숫자와 원래 숫자가 같은 경우 이는 펠린드롬 넘버가 된다. 12321 이런 숫자!!! 그리고 문제의 조건을 잘 읽어 야 한다. 무조건 연산을 한번 이상 적용해야 한다는 점!!!! 그리고 3번 이내의 연산으로 만들 수 없는 경우 끝나버리는 것, 연산과정에서 결과가 10000이상이 되버리는 경우 모두 순서를 잘 지켜서 조건을 적어줘야 한다. !!!! 이렇게 깊이 제한이 있을 때 주의해야 할 것은 깊이가 한번 돌 때 무조건 1씩증가하는지의 여부이다. 만약 깊이가 증가하지 않을 수도 있다면 예를 들면 사천성같이 그러면 깊이가3일때 break 이런 문장을 적용하면 안된다. 그럴 때는 큐에 넣지 않는다던지 등으로 해서 해결해야 한다. "
2016 3번,단어찾아내기,o,"단어를 공백으로 자르고 해당 공백이 나오기 전까지의 단어를 배열에 넣음으로써 단어를 split할 수 있다. 이 과정을 좀 더 응용하면, 공백이 아니더라도 특수문자가 나오면 자를 수 있다. 또한 맨 마지막 단어도 처리해줘야 하므로 맨 마지막에 \n을 더해주고 돌리자. 또한 이 과정을 응용하면 해당 단어를 모음은 1로 자음은 0으로 바꾸는 작업도 할 수 있으니 잘 활용할 것!!!! "
2016 4번,큰 수와 작은 수의 합,o,"큰 수를 만드는 알고리즘을 잘 생각해보면, 일단 숫자의 맨 앞자리 숫자가 가장 큰 녀석들부터 만들어 나가야 한다. ->즉 앞자리가 9인것 배열,8인것 배열,이렇게 9개의 배열로 분류해야 하며, 또한 해당 배열안에서도, 1자리수라고 무조건 제일 작은 것이아니라 해당 숫자보다 두번째 자리수 숫자가 더 작다면 작은 수로 취급하는 것이 관건이다.!!! 이것은 배열을 자유자재로 정렬하거나, 쪼개거나 새롭게 만드는 작업이 필요하므로 python을 이용했다. "
2015 1번,길확인하기,,"부모의 방향이 자기가 가진 방향과 같은지 확인하고,자기가 갈 방향을 다음큐의 부모자리에 넣고 비교해서 집어넣는다. 이 문제는 갈 방향이 2개밖에 없으므로 코드를 최소화 할 수 있다. 문제 조건을 잘 읽는 것이 중요하다."
,괄호 짝 맞추기,o,"스택을 이용하는 전형적인 문제, 스택에(,{,[를 넣고 그 반대가 나올 때 마다 팝해서 비교하는 것, 스택에 뭐가 남아있으면 틀린것이고, 팝한 것과 현재 값이 짝이 맞지 않다면 틀린것이다. "
,단어 빈도 추출,o,"빈도 추출할 때 우선 단어를 만드는 것이 중요한데, 위에서 단어찾아내기에 쓴 알고리즘으로 공백,특수기호를 깆준으로 쪼갠 단어들 집합을 먼저 만든다. 그리고 딕셔너리를 이용해서 단어 등장회수를 ky로 만들고 정렬한다. 정렬 후, 해당 빈도수를 가진 단어들의 배열을 다시 사전순으로 정렬하여 출력한다."
,사천성 시뮬레이터,o,"bfs알고리즘으로 풀면 되는데 가장 중요한 핵심은 22222하다가 정답을 만날 수 있다는 점이다. 즉 깊이가 무조건 3이라고해서 그만두면 안된다. 23222이런식으로 큐에 있을 수도 있다는 점이다. 그리고 방문체크 꼭 해주고, 갈 수 있는 범위를 벗어났는지 꼭 체크해주고 bfs기본적인 것을 잘 지켜주고, 방향 바꾸는것을 잘 활용하면 되는 문제,,!!!"
